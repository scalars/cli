/* eslint-disable @typescript-eslint/no-unused-vars */

import { DocumentNode } from 'graphql'
import fetch from 'node-fetch';
import { ApolloClient, ApolloLink, HttpLink, InMemoryCache, NormalizedCacheObject, FetchPolicy, gql } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';

export enum ClientType {
    IMPLICIT = 'implicit',
    CODE = 'code'
}

type FetchFunction = ( uri: string, options: any ) => Promise<any>
type ApolloClients = {
    [key in ClientType]: {
        client: ApolloClient<NormalizedCacheObject>|null
        fetch?: FetchFunction
        credentials?: string
        token?: string
    }
}

interface ApolloOptions {
    fetchPolicy?: FetchPolicy
}

interface MutationApolloOptions {
    fetchPolicy?: Extract<FetchPolicy, 'no-cache'>
}

interface ClientOptions {
    client?: ClientType
    apolloOptions?: ApolloOptions
}

interface MutationClientOptions {
    client?: ClientType
    apolloOptions?: MutationApolloOptions
}

{{#schemaTypes}}
{{{.}}}
{{/schemaTypes}}

{{#selects}}
export type {{name}} = {
    {{#fields}}
    {{name}}?: {{type}}
    {{/fields}}
}
{{/selects}}

{{#returns}}
export type I{{type}} = Partial<{{{type}}}>
{{/returns}}

const parseSelectFields = ( select: Record<string ,any> ): string => {
    let fields: string = ''
    Object.keys( select ).forEach( key => {
        if ( typeof select[key] === 'boolean' ) {
            fields = fields.concat( `${key} ` )
        }
        else {
            fields = fields.concat( `${key} { ${parseSelectFields( select[key] )}} ` )
        }
    } )
    return fields
}

const fillSelectedFields = ( operation: string, select: Record<string, any> ): DocumentNode => {
    return gql`${operation.replace( '#@@', parseSelectFields( select ) )}`
}

class ScalarsClientManager {
    private readonly apolloClients: ApolloClients
    private readonly defaultClientType: ClientType
    private readonly cache: InMemoryCache
    private readonly uri: string

    constructor ( uri: string, token: string, defaultClientType: ClientType = ClientType.IMPLICIT ) {
        if ( !uri ) {
            throw new Error( 'URI is empty' )
        }
        this.defaultClientType = defaultClientType;
        this.uri = uri;
        this.cache = new InMemoryCache( { addTypename: false } )
        this.apolloClients = {
            [ClientType.IMPLICIT]: {
                client: null,
                credentials: 'omit',
                token
            },
            [ClientType.CODE]: {
                client: null,
                credentials: 'include'
            }
        }
    }

    getClient ( name: ClientType = this.defaultClientType, ssrMode: boolean = false ): ApolloClient<NormalizedCacheObject> {
        const apolloClient = this.apolloClients[name]
        if ( apolloClient && !apolloClient.client) {
            const { credentials, token } = apolloClient
            let authLink: ApolloLink | undefined;
            if ( token ) {
                authLink = setContext( ( _, { headers } ) => {
                    return {
                        headers: { ...headers, Authorization: token }
                    }
                } )
            }
            const httpLink = new HttpLink( {
                uri: this.uri,
                credentials,
                fetch: fetch as any,
                fetchOptions: {
                    credentials
                }
            } )
            apolloClient.client = new ApolloClient<NormalizedCacheObject>( {
                link: authLink ? authLink.concat( httpLink ) : httpLink,
                cache: this.cache,
                ssrMode
            } )
        }
        return apolloClient.client as ApolloClient<NormalizedCacheObject>
    }
}

class Service {
    private readonly scalarsClientManager: ScalarsClientManager

    constructor () {
        this.scalarsClientManager = new ScalarsClientManager(
            {{#config}}'{{{endpoint}}}'{{/config}},
            'client_id {{#config}}{{clientId}}{{/config}}',
        )
    }

    async doQuery<T, U> (
        query: DocumentNode,
        variables?: U,
        clientOptions?: ClientOptions
    ): Promise<T> {
        const client: ApolloClient<NormalizedCacheObject> = this.scalarsClientManager.getClient( clientOptions?.client )
        try {
            const response = await client.query( {
                fetchPolicy: 'network-only',
                query,
                variables,
                ...clientOptions?.apolloOptions
            } )
            return Service.getResponse<T>( response as any )
        }
        catch ( error ) {
            // console.log(`Hubo un error`, error)
            return Service.getResponse<T>( { error } as any );
        }
    }

    async doMutation<T, U> (
        mutation: DocumentNode,
        variables?: U,
        clientOptions?: MutationClientOptions
    ): Promise<T> {
        const client: ApolloClient<NormalizedCacheObject> = this.scalarsClientManager.getClient( clientOptions?.client )
        try {
            const response = await client.mutate( {
                mutation,
                variables,
                ...clientOptions?.apolloOptions
            } )
            return Service.getResponse<T>( response as any )
        }
        catch ( error ) {
            // console.log(`Hubo un error`, error)
            return Service.getResponse<T>( { error } as any );
        }
    }

    private static getResponse<T> ( { data, error }: { data: T, error: T } ): T {
        if ( data ) {
            return data;
        }
        throw error;
    }
}

class QueriesService extends Service {
    {{#operations}}
    {{#queries}}
    async {{operation}} ( args: {
        select?: {{#select}}{{name}}{{/select}},
        {{#args}}
        {{name}}{{^requiredType}}?{{/requiredType}}: {{{type}}},
        {{/args}}
        clientOptions?: ClientOptions
    } ): Promise<{{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}> {
        const get{{_operation}}Query: string = `
            query get{{_operation}} (
            {{#args}}
                ${{name}}: {{#scalarType}}{{.}}{{/scalarType}}{{^scalarType}}{{{type}}}{{/scalarType}}{{#requiredType}}!{{/requiredType}},
            {{/args}}
            ) {
                {{operation}} (
                    {{#args}}
                    {{name}}: ${{name}},
                    {{/args}}
                ) {
                    #@@
                }
            }
        `
        const { {{operation}} } = await this.doQuery<Record<'{{operation}}', {{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}>, Query{{_operation}}Args>( fillSelectedFields( get{{_operation}}Query, args.select || { id: true } ), {
            {{#args}}
            args.{{name}},
            {{/args}}
        }, args.clientOptions )
        return {{operation}}
    }
    {{/queries}}
    {{/operations}}
}

class MutationsService extends Service {
    {{#operations}}
    {{#mutations}}
    async {{operation}} ( args: {
        select?: {{#select}}{{name}}{{/select}},
        {{#args}}
        {{name}}{{^requiredType}}?{{/requiredType}}: {{{type}}},
        {{/args}}
        clientOptions?: MutationClientOptions
    } ): Promise<{{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}> {
        const {{_operation}}Mutation: string = `
            mutation {{_operation}} (
            {{#args}}
                ${{name}}: {{#scalarType}}{{.}}{{/scalarType}}{{^scalarType}}{{{type}}}{{/scalarType}}{{#requiredType}}!{{/requiredType}},
            {{/args}}
            ) {
                {{operation}} (
                {{#args}}
                    {{name}}: ${{name}},
                {{/args}}
                ) {
                    #@@
                }
            }
        `
        const { {{operation}} } = await this.doMutation<Record<'{{operation}}', {{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}>, Mutation{{_operation}}Args>( fillSelectedFields( {{_operation}}Mutation, args.select || { id: true } ), {
            {{#args}}
            args.{{name}},
            {{/args}}
        }, args.clientOptions )
        return {{operation}}
    }
    {{/mutations}}
    {{/operations}}
}

export class ScalarsClient {
    private readonly queriesService: QueriesService
    private readonly mutationsService: MutationsService
    private readonly genericService: Service

    constructor() {
        this.queriesService = new QueriesService()
        this.mutationsService = new MutationsService()
        this.genericService = new Service()
    }

    get query () {
        return this.queriesService
    }

    get mutation () {
        return this.mutationsService
    }

    async doQuery ( query: string, variables: Record<string, any>, clientOptions?: ClientOptions ): Promise<Record<string, any>> {
        return await this.genericService.doQuery<Record<string, any >, Record<string, any>>( gql`${query}`, variables, clientOptions )
    }

    async doMutation ( mutation: string, variables: Record<string, any>, clientOptions?: MutationClientOptions ): Promise<Record<string, any>> {
        return await this.genericService.doMutation<Record<string, any >, Record<string, any>>( gql`${mutation}`, variables, clientOptions )
    }
}
