/* eslint-disable @typescript-eslint/no-unused-vars */

import { DocumentNode } from 'graphql'
import fetch from 'node-fetch';
import { ApolloClient, ApolloLink, HttpLink, InMemoryCache, NormalizedCacheObject, FetchPolicy, gql } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';

type TokenFunction = ()=> string | string

export interface ScalarsClientConfig {
    endpoint: string,
    getToken: TokenFunction
}

export enum ClientType {
    CLIENT_ID = 'explicit', // THIS WILL REPLACE IMPLICIT
    COOKIE = 'cookie', // THIS WILL REPLACE CODE
}

type FetchFunction = ( uri: string, options: any )=> Promise<any>
type ApolloClients = {
    [key in ClientType]: {
        client: ApolloClient<NormalizedCacheObject>|null
        fetch?: FetchFunction
        credentials?: string
        token?: string
    }
}

interface ApolloOptions {
    fetchPolicy?: FetchPolicy
}

interface MutationApolloOptions {
    fetchPolicy?: Extract<FetchPolicy, 'no-cache'>
}

interface ClientOptions {
    client?: ClientType
    auth?: boolean
    apolloOptions?: ApolloOptions
}

interface MutationClientOptions {
    client?: ClientType
    auth?: boolean
    apolloOptions?: MutationApolloOptions
}

{{#schemaTypes}}
{{{.}}}
{{/schemaTypes}}

{{#selects}}
export type {{name}} = {
    {{#fields}}
    {{name}}?: {{type}}
    {{/fields}}
}
{{/selects}}

{{#returns}}
export type I{{type}} = Partial<{{{type}}}>
{{/returns}}

const parseSelectFields = ( select: Record<string ,any> ): string => {
    let fields: string = ''
    Object.keys( select ).forEach( key => {
        if ( typeof select[key] === 'boolean' ) {
            fields = fields.concat( `${key} ` )
        }
        else {
            fields = fields.concat( `${key} { ${parseSelectFields( select[key] )}} ` )
        }
    } )
    return fields
}

const fillSelectedFields = ( operation: string, select: Record<string, any> ): DocumentNode => {
    return gql`${operation.replace( '#@@', parseSelectFields( select ) )}`
}


class QueriesService extends Service {
    {{#operations}}
    {{#queries}}
    async {{operation}} ( args: {
        select?: {{#select}}{{name}}{{/select}},
        {{#args}}
        {{name}}{{^requiredType}}?{{/requiredType}}: {{{type}}},
        {{/args}}
        clientOptions?: ClientOptions
    } ): Promise<{{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}> {
        const get{{_operation}}Query: string = `
            query get{{_operation}} (
            {{#args}}
                ${{name}}: {{#scalarType}}{{.}}{{/scalarType}}{{^scalarType}}{{{type}}}{{/scalarType}}{{#requiredType}}!{{/requiredType}},
            {{/args}}
            ) {
                {{operation}} (
                    {{#args}}
                    {{name}}: ${{name}},
                    {{/args}}
                ) {
                    #@@
                }
            }
        `
        const { {{operation}} } = await this.doQuery<Record<'{{operation}}', {{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}>, Query{{_operation}}Args>(
            fillSelectedFields( get{{_operation}}Query, args.select || { id: true } ),
            Object.fromEntries( Object.entries( args ).filter( ( [ k, v ] ) =>  v !== null && k !== 'select' && k !== 'clientOptions' ) ) as Query{{_operation}}Args,
            { ...args.clientOptions, auth: {{#authOperation}}true{{/authOperation}}{{^authOperation}}false{{/authOperation}} }
        )
        return {{operation}}
    }
    {{/queries}}
    {{/operations}}
}

class MutationsService extends Service {
    {{#operations}}
    {{#mutations}}
    async {{operation}} ( args: {
        select?: {{#select}}{{name}}{{/select}},
        {{#args}}
        {{name}}{{^requiredType}}?{{/requiredType}}: {{{type}}},
        {{/args}}
        clientOptions?: MutationClientOptions
    } ): Promise<{{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}> {
        const {{_operation}}Mutation: string = `
            mutation {{_operation}} (
            {{#args}}
                ${{name}}: {{#scalarType}}{{.}}{{/scalarType}}{{^scalarType}}{{{type}}}{{/scalarType}}{{#requiredType}}!{{/requiredType}},
            {{/args}}
            ) {
                {{operation}} (
                {{#args}}
                    {{name}}: ${{name}},
                {{/args}}
                ) {
                    #@@
                }
            }
        `
        const { {{operation}} } = await this.doMutation<Record<'{{operation}}', {{#return}}{{#list}}Array<I{{{type}}}{{^requiredType}} | null{{/requiredType}}>{{^requiredList}} | null {{/requiredList}}{{/list}}{{^list}}I{{{type}}}{{^requiredType}} | null{{/requiredType}}{{/list}}{{/return}}>, Mutation{{_operation}}Args>(
            fillSelectedFields( {{_operation}}Mutation, args.select || { id: true } ),
            Object.fromEntries( Object.entries( args ).filter( ( [ k, v ] ) =>  v !== null && k !== 'select' && k !== 'clientOptions' ) ) as Mutation{{_operation}}Args,
            { ...args.clientOptions, auth: {{#authOperation}}true{{/authOperation}}{{^authOperation}}false{{/authOperation}} }
        )
        return {{operation}}
    }
    {{/mutations}}
    {{/operations}}
}
